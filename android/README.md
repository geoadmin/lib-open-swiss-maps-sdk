<h1 align="center">OpenSwissMapsSDK</h1>

<br />

<div align="center">
    <!-- SPM -->
    <a href="https://github.com/apple/swift-package-manager">
      <img alt="Swift Package Manager"
      src="https://img.shields.io/badge/SPM-%E2%9C%93-brightgreen.svg?style=flat">
    </a>
    <!-- License -->
    <a href="https://github.com/geoadmin/lib-open-swiss-maps-sdk/blob/master/LICENSE">
      <img alt="TODO" src="TODO">
    </a>
    <!-- iOS Build -->
    <a href="https://github.com/geoadmin/lib-open-swiss-maps-sdk/actions/workflows/ios.yml">
      <img alt="Build status: iOS"
      src="https://github.com/geoadmin/lib-open-swiss-maps-sdk/actions/workflows/ios.yml/badge.svg">
    </a>
    <!-- android Build -->
    <a href="https://github.com/geoadmin/lib-open-swiss-maps-sdk/actions/workflows/android.yml">
      <img alt="Build status: android"
      src="https://github.com/geoadmin/lib-open-swiss-maps-sdk/actions/workflows/android.yml/badge.svg">
    </a>
</div>



## How to build

Make sure you have all submodules (and their respective submodules) initialized and updated. To do this, use

```
git submodule update --init --recursive
```

### Updating Djinni bridging files

The bridging interface between Kotlin and C++ are defined in the djinni files under [djinni](../djinni). After modifying those files the new bridging code can be generated by running

```make clean djinni```

in the folder [djinni](../djinni). This generates the Kotlin bindings, the C++ header files as well as all the JNI glue code.

### Building the Android Library

The Android library can be opened as an Android Studio project in the [android](.) folder. Alternatively, you can build the library using gradle from the command line using

```
./gradlew assemble
```

and you find the generated .aar library under `build/outputs/aar/`. For development, it is easiest to include this library directly as a module into a wrapping Android application project, that can be run on a device.

<h2>Installation</h2>

Either include the `android` folder as a module in the Android project or move the generated .aar to e.g. the `app/libs` folder of the project and include it in the project via the apps `build.gradle`:

```
implementation fileTree(dir: 'libs', include: ['*.aar'])
```

### Dependencies

When the Open Swiss Maps is included as .aar, the following dependencies in the apps `build.gradle` are necessary:

```
implementation "androidx.activity:activity-ktx:1.1.0"
implementation "androidx.lifecycle:lifecycle-runtime-ktx:2.2.0"
implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.4.2"
implementation 'com.squareup.okhttp3:okhttp:4.7.2' // used for the default TextureLoader
```

<h2>How to use</h2>

### Display a Swisstopo Map

The SDK provides the `SwisstopoMapView` for configuring and displaying maps.  To use it, simply include it in a layout and register it to the lifecycle of the activity or fragment that contains the view. This is necessary for the execution of map internal tasks such as tile-loading.

```Kotlin
val mapView = findViewById<SwisstopoMapView>(R.id.map_view)
mapView.registerLifecycle(lifecycle)
```

##### Changing the default layer type

The map contains a base-layer that displays the `ch.swisstopo.pixelkarte-farbe` layer by default. The base-layer's type can be changed (or removed by passing `null`) at any time. For example with:

```Kotlin
mapView.setBaseLayerType(SwisstopoLayerType.SWISSIMAGE)
```

##### Adding multiple Swisstopo layers

New layers can easily be created with the `SwisstopoLayerFactory` and added to the map. Their transparency value can be adjusted by calling `setAlpha` on the layer object.

 ```Kotlin
val layer = SwisstopoLayerFactory.createSwisstopoTiledRasterLayer(SwisstopoLayerType.DROHNEN, mapView.textureLoader)
layer.setAlpha(0.5)
mapView.addLayer(layer.asLayerInterface())
 ```

##### Adjusting the Camera

The camera position can easily be adjusted by manipulating the `Camera2dInterface` received from the map. E.g. to set it to a custom location:

```Kotlin
mapView.getCamera()
	.moveToCenterPositionZoom(Coord(CoordinateSystemIdentifiers.EPSG4326(), 8.543912536386152, 47.37623511643675, 0.0), 
	3000.0,
	true)
```

One can also change the default values for the camera's bounds and it's zoom range:

```kotlin
mapView.getCamera().setBounds(RectCoord(Coord(CoordinateSystemIdentifiers.EPSG2056(), 2485071.58, 1299941.79, 0.0), Coord(CoordinateSystemIdentifiers::EPSG2056(), 2828515.82, 1075346.31, 0.0)))
mapView.getCamera().setMinZoom(5000000.0)
mapView.getCamera().setMaxZoom(250.0)
```

##### Reacting to layer clicks

To react to user interaction with a layer, a callback handler can be set. E.g. on the baseLayer in the map (or any other tiled raster layer)

```kotlin
mapView.baseLayer?.setCallbackHandler(object : Tiled2dMapRasterLayerCallbackInterface() {
   override fun onClickConfirmed(coord: Coord): Boolean {
      // Return true, if the click has been consumed here
      return true
   }

   override fun onLongPress(coord: Coord): Boolean {
      // Return true, if the long press has been consumed here
      return true
   }
})
```

Please note that other layer types expose different functionalities in their callback handlers. The polygon layer, for example, returns the polygon hit by the click.

## License

This project is licensed under the terms of the MPL 2 license. See the [LICENSE](../LICENSE) file.